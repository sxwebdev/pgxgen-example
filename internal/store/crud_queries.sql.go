// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: crud_queries.sql

package store

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO authors ("first_name", "last_name", "email", "phone", "is_active", "notifications", "created_at")
	VALUES ($1, $2, $3, $4, $5, $6, now())
	RETURNING id, first_name, last_name, email, phone, is_active, notifications, created_at, updated_at
`

type CreateAuthorParams struct {
	FirstName     string              `db:"first_name" json:"first_name"`
	LastName      string              `db:"last_name" json:"last_name"`
	Email         string              `db:"email" json:"email"`
	Phone         *string             `db:"phone" json:"phone"`
	IsActive      bool                `db:"is_active" json:"is_active"`
	Notifications AuthorNotifications `db:"notifications" json:"notifications"`
}

func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (*Author, error) {
	row := q.db.QueryRow(ctx, createAuthor,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.IsActive,
		arg.Notifications,
	)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.IsActive,
		&i.Notifications,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO books ("name", "description", "genre", "release_date", "author_id", "created_at")
	VALUES ($1, $2, $3, $4, $5, now())
	RETURNING id, name, description, genre, release_date, author_id, created_at, updated_at
`

type CreateBookParams struct {
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	Genre       BookType  `db:"genre" json:"genre"`
	ReleaseDate time.Time `db:"release_date" json:"release_date"`
	AuthorID    uuid.UUID `db:"author_id" json:"author_id"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (*Book, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.Name,
		arg.Description,
		arg.Genre,
		arg.ReleaseDate,
		arg.AuthorID,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Genre,
		&i.ReleaseDate,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteAuthor = `-- name: DeleteAuthor :exec
DELETE FROM authors WHERE "id"=$1
`

func (q *Queries) DeleteAuthor(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAuthor, id)
	return err
}

const deleteBook = `-- name: DeleteBook :exec
DELETE FROM books WHERE "id"=$1
`

func (q *Queries) DeleteBook(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBook, id)
	return err
}

const findAuthors = `-- name: FindAuthors :many
SELECT id, first_name, last_name, email, phone, is_active, notifications, created_at, updated_at FROM authors ORDER BY "created_at" DESC
`

func (q *Queries) FindAuthors(ctx context.Context) ([]*Author, error) {
	rows, err := q.db.Query(ctx, findAuthors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Author{}
	for rows.Next() {
		var i Author
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.IsActive,
			&i.Notifications,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBooksByAuthorID = `-- name: FindBooksByAuthorID :many
SELECT id, name, description, genre, release_date, author_id, created_at, updated_at FROM books WHERE "author_id"=$1 ORDER BY "created_at" DESC
`

func (q *Queries) FindBooksByAuthorID(ctx context.Context, authorID uuid.UUID) ([]*Book, error) {
	rows, err := q.db.Query(ctx, findBooksByAuthorID, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Book{}
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Genre,
			&i.ReleaseDate,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthorByID = `-- name: GetAuthorByID :one
SELECT id, first_name, last_name, email, phone, is_active, notifications, created_at, updated_at FROM authors WHERE "id"=$1
`

func (q *Queries) GetAuthorByID(ctx context.Context, id uuid.UUID) (*Author, error) {
	row := q.db.QueryRow(ctx, getAuthorByID, id)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.IsActive,
		&i.Notifications,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getBookByID = `-- name: GetBookByID :one
SELECT id, name, description, genre, release_date, author_id, created_at, updated_at FROM books WHERE "id"=$1
`

func (q *Queries) GetBookByID(ctx context.Context, id uuid.UUID) (*Book, error) {
	row := q.db.QueryRow(ctx, getBookByID, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Genre,
		&i.ReleaseDate,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const totalAuthors = `-- name: TotalAuthors :one
SELECT count(*) as total FROM authors
`

func (q *Queries) TotalAuthors(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalAuthors)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const totalBooks = `-- name: TotalBooks :one
SELECT count(*) as total FROM books
`

func (q *Queries) TotalBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalBooks)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const updateAuthor = `-- name: UpdateAuthor :one
UPDATE authors
	SET "first_name"=$1, "last_name"=$2, "email"=$3, "phone"=$4, "is_active"=$5, "notifications"=$6, 
		"updated_at"=now()
	WHERE "id"=$7
	RETURNING id, first_name, last_name, email, phone, is_active, notifications, created_at, updated_at
`

type UpdateAuthorParams struct {
	FirstName     string              `db:"first_name" json:"first_name"`
	LastName      string              `db:"last_name" json:"last_name"`
	Email         string              `db:"email" json:"email"`
	Phone         *string             `db:"phone" json:"phone"`
	IsActive      bool                `db:"is_active" json:"is_active"`
	Notifications AuthorNotifications `db:"notifications" json:"notifications"`
	ID            uuid.UUID           `db:"id" json:"id"`
}

func (q *Queries) UpdateAuthor(ctx context.Context, arg UpdateAuthorParams) (*Author, error) {
	row := q.db.QueryRow(ctx, updateAuthor,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.IsActive,
		arg.Notifications,
		arg.ID,
	)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.IsActive,
		&i.Notifications,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateBook = `-- name: UpdateBook :one
UPDATE books
	SET "name"=$1, "description"=$2, "genre"=$3, "release_date"=$4, "updated_at"=now()
	WHERE "id"=$5
	RETURNING id, name, description, genre, release_date, author_id, created_at, updated_at
`

type UpdateBookParams struct {
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	Genre       BookType  `db:"genre" json:"genre"`
	ReleaseDate time.Time `db:"release_date" json:"release_date"`
	ID          uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) (*Book, error) {
	row := q.db.QueryRow(ctx, updateBook,
		arg.Name,
		arg.Description,
		arg.Genre,
		arg.ReleaseDate,
		arg.ID,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Genre,
		&i.ReleaseDate,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
